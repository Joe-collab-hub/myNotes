<!--
  ~ Time:2022/2/21 11:18 07
  ~ Name:原型对象.html
  ~ Path:js/笔记/06.js
  ~ ProjectName:前端
  ~ Author:突然
  ~
  ~  Il n'ya qu'un héroïsme au monde : c'est de voir le monde tel qu'il est et de l'aimer.
  -->
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta content="IE=edge" http-equiv="X-UA-Compatible">
	<meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
	<title>原型对象</title>

</head>
<body>

</body>
<script>
	/*
	*   原型prototype
	*
	*       我们所创建的每一个函数，解析器都会向函数添加一个属性prototype
	*           这个属性对应着一个对象，这个对象是我们所得的原型对象
	*       如果函数作为普通函数调用prototype没有任何作用
	*       当函数通过构造函数的形式调用，它所创建的对象中都会有一个隐含的属性
	*           指向该构造函数的原型对象
	*
	*       原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，
	*           我们可以将对象中共有的内容，统一设置到原型对象中
	*
	*       当我们访问对象的一个属性或方法时，它会先在自身中寻找，如果有则直接使用，
	*           没有则会去原型对象中寻找，如果找到则直接使用
	*
	*       以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，
	*           这样不用分别每一个对象添加，也不会影响到全局作用域，就可以使用每个对象都具有这些属性和方法了
	*/

	function MyClass () {

	}

	// 向MyClass的原型中添加属性a
	MyClass.prototype.a = 123
	// 向MyClass的原型中添加一个方法
	MyClass.prototype.sayHello = function () {
		alert('hello')
	}

	let mc = new MyClass()

	let mc2 = new MyClass()

	// console.log(
	// MyClass.prototype);

	// console.log(mc.__proto__ === MyClass.prototype);
	// console.log(mc2.__proto__ === MyClass.prototype);

	// 向mc中添加a属性
	mc.a = '我是mc中的a'

	// console.log(mc.a)
	mc.sayHello()
</script>
</html>
